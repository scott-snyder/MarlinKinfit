Bottom: 6601743a61a6ec40311c536ba9556c2799d3873a
Top:    fe09bc2fb6bf901d2de5ff3753c5357eb56897d0
Author: scott snyder <sss@karma>
Date:   2020-02-12 11:47:17 -0500

Fix compilation warnings.


---

diff --git a/include/BaseFitObject.h b/include/BaseFitObject.h
index 212b84a..9caa588 100644
--- a/include/BaseFitObject.h
+++ b/include/BaseFitObject.h
@@ -185,7 +185,7 @@ class BaseFitObject {
     virtual double getParam (int ilocal     ///< Local parameter number
                             ) const;
     /// Get name of parameter ilocal
-    virtual const char *getParamName (int ilocal     ///< Local parameter number
+    virtual const char *getParamName (int /*ilocal*/     ///< Local parameter number
                             ) const { return "???";}
     /// Get object's name
     //    virtual const char *getName () const { return name ? name : "???";}
diff --git a/include/TrackParticleFitObject.h b/include/TrackParticleFitObject.h
index b415c62..4f0a533 100644
--- a/include/TrackParticleFitObject.h
+++ b/include/TrackParticleFitObject.h
@@ -98,10 +98,10 @@ class TrackParticleFitObject : public ParticleFitObject {
 
   /// Set parameters such that track passes through a vertex with a given 4-momentum; return=success
   // only needed for unmeasured tracks, I think
-  virtual bool  setParameters (int ivertex,                  ///< Vertex number: 0=start, 1=stop
-			       const ThreeVector& vertex,    ///< Vertex position
-			       const FourVector& momentum,   ///< Four-momentum
-			       double charge_                ///< Charge (signed, in units of e)
+  virtual bool  setParameters (int /*ivertex*/,                  ///< Vertex number: 0=start, 1=stop
+			       const ThreeVector& /*vertex*/,    ///< Vertex position
+			       const FourVector& /*momentum*/,   ///< Four-momentum
+			       double /*charge_*/                ///< Charge (signed, in units of e)
                                ) {assert(0);}
 
   /// Get helix that is tangential at a certain arc length s
diff --git a/include/VertexFitObject.h b/include/VertexFitObject.h
index d58d32b..9de5b98 100644
--- a/include/VertexFitObject.h
+++ b/include/VertexFitObject.h
@@ -169,7 +169,7 @@ class VertexFitObject: public BaseFitObject {
                                             ) const;
 
 
-    virtual void getDerivatives (double der[], int idim) const {}
+    virtual void getDerivatives (double /*der*/[], int /*idim*/) const {}
 
 //    /// Add covariance matrix elements to 
 //    /// global covariance matrix of size idim x idim
diff --git a/src/BaseFitObject.cc b/src/BaseFitObject.cc
index d7358a8..f9ed4eb 100644
--- a/src/BaseFitObject.cc
+++ b/src/BaseFitObject.cc
@@ -515,7 +515,7 @@ void BaseFitObject::addToGlobalChi2DerVector (double *y, int idim) const {
 }
 
 
-void BaseFitObject::addToGlobalChi2DerVector (double *y, int idim, 
+void BaseFitObject::addToGlobalChi2DerVector (double *y, int /*idim*/, 
 					      double lambda, double der[], int metaSet ) const {
   // DANIEL moved to BaseFitObject 
   // this adds the lambda * dConst/dpar piece
diff --git a/src/ISRPhotonFitObject.cc b/src/ISRPhotonFitObject.cc
index 5620e68..5e1ebab 100644
--- a/src/ISRPhotonFitObject.cc
+++ b/src/ISRPhotonFitObject.cc
@@ -117,7 +117,8 @@ ISRPhotonFitObject::~ISRPhotonFitObject() {}
 
 
 ISRPhotonFitObject::ISRPhotonFitObject (const ISRPhotonFitObject& rhs)
-  : cachevalid(false),    
+  : ParticleFitObject(rhs),
+    cachevalid(false),    
     pt2(0), p2(0), p(0), pz(0),
     dpx0(0), dpy0(0), dpz0(0), dE0(0), dpx1(0), dpy1(0), dpz1(0), dE1(0),
     dpx2(0), dpy2(0), dpz2(0), dE2(0), d2pz22(0), d2E22(0),
diff --git a/src/JetFitObject.cc b/src/JetFitObject.cc
index 7cb06a8..36a51be 100644
--- a/src/JetFitObject.cc
+++ b/src/JetFitObject.cc
@@ -120,7 +120,8 @@ JetFitObject::JetFitObject(double E, double theta, double phi,
 JetFitObject::~JetFitObject() {}
 
 JetFitObject::JetFitObject (const JetFitObject& rhs)
-  : ctheta(0), stheta(0), cphi(0), sphi(0),
+  : ParticleFitObject(rhs),
+    ctheta(0), stheta(0), cphi(0), sphi(0),
     p2(0), p(0), pt(0), px(0), py(0), pz(0), dpdE(0), dptdE(0), 
     dpxdE(0), dpydE(0), dpzdE(0), dpxdtheta(0), dpydtheta(0), chi2(0)
 {
diff --git a/src/LeptonFitObject.cc b/src/LeptonFitObject.cc
index 4bebac5..b65bd9b 100644
--- a/src/LeptonFitObject.cc
+++ b/src/LeptonFitObject.cc
@@ -199,7 +199,8 @@ LeptonFitObject::LeptonFitObject(const TrackState* trackstate, double Bfield, do
 LeptonFitObject::~LeptonFitObject() {}
 
 LeptonFitObject::LeptonFitObject (const LeptonFitObject& rhs)
-  : ctheta(0), stheta(0), stheta2(0), cphi(0), sphi(0), cottheta(0),
+  : ParticleFitObject(rhs),
+    ctheta(0), stheta(0), stheta2(0), cphi(0), sphi(0), cottheta(0),
     p2(0), p(0), e(0), e2(0), pt(0), pt2(0), pt3(0), px(0), py(0), pz(0), dpdptinv(0), dpdtheta(0), dptdptinv(0),
     dpxdptinv(0), dpydptinv(0), dpzdptinv(0), dpxdtheta(0), dpydtheta(0), dpzdtheta(0), dpxdphi(0), dpydphi(0), dpzdphi(0),
     chi2(0), dEdptinv(0), dEdtheta(0), dEdp(0), qsign(0), ptinv2(0)
@@ -452,7 +453,7 @@ void LeptonFitObject::updateCache() const {
 //  return chi2;
 //}
 
-bool LeptonFitObject::adjustPtinvThetaPhi (double& m, double &ptinv, double& theta, double& phi) {
+bool LeptonFitObject::adjustPtinvThetaPhi (double& /*m*/, double &/*ptinv*/, double& theta, double& phi) {
   bool result = false;
   
 /*  Keep the sign information - off-diagonal terms of the error matrix care about this ...  Graham
diff --git a/src/MomentumConstraint.cc b/src/MomentumConstraint.cc
index c587c22..616715c 100644
--- a/src/MomentumConstraint.cc
+++ b/src/MomentumConstraint.cc
@@ -100,11 +100,11 @@ void MomentumConstraint::updateCache() const {
   cachevalid = true;
 }
   
-bool MomentumConstraint::secondDerivatives (int i, int j, double *dderivatives) const {
+bool MomentumConstraint::secondDerivatives (int /*i*/, int /*j*/, double */*dderivatives*/) const {
   return false;
 }  
   
-bool MomentumConstraint::firstDerivatives (int i, double *dderivatives) const {
+bool MomentumConstraint::firstDerivatives (int /*i*/, double *dderivatives) const {
   dderivatives[0] = efact;
   dderivatives[1] = pxfact;
   dderivatives[2] = pyfact;
diff --git a/src/NeutrinoFitObject.cc b/src/NeutrinoFitObject.cc
index c88aed7..2486021 100644
--- a/src/NeutrinoFitObject.cc
+++ b/src/NeutrinoFitObject.cc
@@ -46,7 +46,8 @@ NeutrinoFitObject::NeutrinoFitObject(double E, double theta, double phi,
 NeutrinoFitObject::~NeutrinoFitObject() {}
 
 NeutrinoFitObject::NeutrinoFitObject (const NeutrinoFitObject& rhs)
-  : ctheta(0), stheta(0), cphi(0), sphi(0), pt(0), px(0), py(0), pz(0), dptdE(0), 
+  : ParticleFitObject(rhs),
+    ctheta(0), stheta(0), cphi(0), sphi(0), pt(0), px(0), py(0), pz(0), dptdE(0), 
     dpxdE(0), dpydE(0), dpxdtheta(0), dpydtheta(0), chi2(0)
 {
   //std::cout << "copying NeutrinoFitObject with name" << rhs.name << std::endl;
diff --git a/src/NewFitterGSL.cc b/src/NewFitterGSL.cc
index ba488ca..4bea958 100755
--- a/src/NewFitterGSL.cc
+++ b/src/NewFitterGSL.cc
@@ -78,35 +78,35 @@ NewFitterGSL::NewFitterGSL()
 // destructor
 NewFitterGSL::~NewFitterGSL() {
 
-  if (x) gsl_vector_free (x);               x=0;
-  if (xold) gsl_vector_free (xold);         xold=0;
-  if (xnew) gsl_vector_free (xnew);         xnew=0;
-//   if (xbest) gsl_vector_free (xbest);       xbest=0;
-  if (dx) gsl_vector_free (dx);             dx=0;
-  if (dxscal) gsl_vector_free (dxscal);     dxscal=0;
-//   if (grad) gsl_vector_free (grad);         grad=0;
-  if (y) gsl_vector_free (y);               y=0;
-  if (yscal) gsl_vector_free (yscal);       yscal=0;
-  if (perr) gsl_vector_free (perr);         perr=0;
-  if (v1) gsl_vector_free (v1);             v1=0;
-  if (v2) gsl_vector_free (v2);             v2=0;
-//   if (Meval) gsl_vector_free (Meval);       Meval=0;
-  if (M) gsl_matrix_free (M);               M=0;
-  if (Mscal) gsl_matrix_free (Mscal);       Mscal=0;
-  if (W) gsl_matrix_free (W);               W=0;
-  if (W2) gsl_matrix_free (W2);             W2=0;
-  if (W3) gsl_matrix_free (W3);             W3=0;
-  if (M1) gsl_matrix_free (M1);             M1=0;
-  if (M2) gsl_matrix_free (M2);             M2=0;
-  if (M3) gsl_matrix_free (M3);             M3=0;
-  if (M4) gsl_matrix_free (M4);             M4=0;
-  if (M5) gsl_matrix_free (M5);             M5=0;
-//   if (Mevec) gsl_matrix_free (Mevec);       Mevec=0;
-  if (CC) gsl_matrix_free (CC);             CC=0;
-  if (CC1) gsl_matrix_free (CC1);           CC1=0;
-  if (CCinv) gsl_matrix_free (CCinv);       CCinv=0;
-  if (permW) gsl_permutation_free (permW);  permW=0;
-  if (eigenws) gsl_eigen_symm_free (eigenws); eigenws=0; eigenwsdim=0;
+  if (x) gsl_vector_free (x);
+  if (xold) gsl_vector_free (xold);
+  if (xnew) gsl_vector_free (xnew);
+//   if (xbest) gsl_vector_free (xbest);
+  if (dx) gsl_vector_free (dx);
+  if (dxscal) gsl_vector_free (dxscal);
+//   if (grad) gsl_vector_free (grad);
+  if (y) gsl_vector_free (y);
+  if (yscal) gsl_vector_free (yscal);
+  if (perr) gsl_vector_free (perr);
+  if (v1) gsl_vector_free (v1);
+  if (v2) gsl_vector_free (v2);
+//   if (Meval) gsl_vector_free (Meval);
+  if (M) gsl_matrix_free (M);
+  if (Mscal) gsl_matrix_free (Mscal);
+  if (W) gsl_matrix_free (W);
+  if (W2) gsl_matrix_free (W2);
+  if (W3) gsl_matrix_free (W3);
+  if (M1) gsl_matrix_free (M1);
+  if (M2) gsl_matrix_free (M2);
+  if (M3) gsl_matrix_free (M3);
+  if (M4) gsl_matrix_free (M4);
+  if (M5) gsl_matrix_free (M5);
+//   if (Mevec) gsl_matrix_free (Mevec);
+  if (CC) gsl_matrix_free (CC);
+  if (CC1) gsl_matrix_free (CC1);
+  if (CCinv) gsl_matrix_free (CCinv);
+  if (permW) gsl_permutation_free (permW);
+  if (eigenws) gsl_eigen_symm_free (eigenws);
 }
 
 
@@ -168,7 +168,7 @@ double NewFitterGSL::fit() {
   bool converged = 0;
   ierr = 0;
   
-  double chi2new = calcChi2();
+  double chi2new2 = calcChi2();
   nit = 0;
   
   do {
@@ -208,18 +208,18 @@ double NewFitterGSL::fit() {
 
     gsl_blas_dcopy (xnew, x);    
 
-    chi2new = calcChi2();
-    //cout << "chi2: " << chi2old << " -> " << chi2new << endl;
+    chi2new2 = calcChi2();
+    //cout << "chi2: " << chi2old << " -> " << chi2new2 << endl;
     
 //   *-- Convergence criteria 
 
     ++nit;
     if (nit > 200) ierr = 1;
     
-    converged = (abs (chi2new - chi2old) < 0.0001);
+    converged = (abs (chi2new2 - chi2old) < 0.0001);
                 
-//     if (abs (chi2new - chi2old) >= 0.001)
-//       cout << "abs (chi2new - chi2old)=" << abs (chi2new - chi2old) << " -> try again\n";      
+//     if (abs (chi2new2 - chi2old) >= 0.001)
+//       cout << "abs (chi2new2 - chi2old)=" << abs (chi2new2 - chi2old) << " -> try again\n";      
 //     if (fvalbest >= 1E-3)
 //       cout << "fvalbest=" << fvalbest << " -> try again\n";      
 //     if (fvalbest >= 1E-6 && abs(fvals[0]-fvalbest) >= 0.2*fvalbest )
@@ -229,7 +229,7 @@ double NewFitterGSL::fit() {
 //       cout << "stepbest=" << stepbest << " -> try again\n";      
 //     cout << "converged=" << converged << endl;
     if (debug > 2 && converged) {
-      cout << "abs (chi2new - chi2old)=" << abs (chi2new - chi2old) << "\n"      
+      cout << "abs (chi2new2 - chi2old)=" << abs (chi2new2 - chi2old) << "\n"      
            << "fvalbest=" << fvalbest << "\n"
            << "abs(fvals[0]-fvalbest)=" << abs(fvals[0]-fvalbest)<< "\n";      
     } 
@@ -280,7 +280,7 @@ double NewFitterGSL::fit() {
   }
 
 // *-- Turn chisq into probability.
-  fitprob = (chi2new >= 0 && ncon+nsoft-nunm> 0) ? gsl_cdf_chisq_Q(chi2new, ncon+nsoft-nunm) : -1;
+  fitprob = (chi2new2 >= 0 && ncon+nsoft-nunm> 0) ? gsl_cdf_chisq_Q(chi2new2, ncon+nsoft-nunm) : -1;
   
 #ifndef FIT_TRACEOFF
     if (tracer) tracer->finish (*this);
@@ -769,7 +769,7 @@ int NewFitterGSL::calcNewtonDx (gsl_vector *vecdx, gsl_vector *vecdxscal,
                                 gsl_matrix *MatM, gsl_matrix *MatMscal,  
                                 gsl_vector *vecy, gsl_vector *vecyscal, 
                                 gsl_matrix *MatW, gsl_matrix *MatW2, 
-                                gsl_permutation *permW,
+                                gsl_permutation *permW2,
                                 gsl_vector *vecw
                                ) {
   assert (vecdx);
@@ -792,8 +792,8 @@ int NewFitterGSL::calcNewtonDx (gsl_vector *vecdx, gsl_vector *vecdxscal,
   assert (MatW->size1 == idim && MatW->size2 == idim);
   assert (MatW2);
   assert (MatW2->size1 == idim && MatW2->size2 == idim);
-  assert (permW);
-  assert (permW->size == idim);
+  assert (permW2);
+  assert (permW2->size == idim);
   assert (vecw);
   assert (vecw->size == idim);
   
@@ -1017,7 +1017,7 @@ int NewFitterGSL::calcLimitedDx (double& alpha, double& mu, gsl_vector *vecxnew,
                 
 int NewFitterGSL::doLineSearch (double& alpha, gsl_vector *vecxnew, 
                                 int imode, 
-                                double phi0, double dphi0, double phiR,
+                                double phi0, double dphi0, double /*phiR*/,
                                 double eta, double zeta,  
                                 double mu,
                                 const gsl_vector *vecx, const gsl_vector *vecdx,       
@@ -1066,14 +1066,12 @@ int NewFitterGSL::doLineSearch (double& alpha, gsl_vector *vecxnew,
   updateParams (vecxnew);
     
   double alphaL = 0;
-  double phiL = phi0;
-  double dphiL = dphi0;
   
   double phi, dphi;
-  int nit = 0;
+  int nit2 = 0;
   
   do {
-    nit++;
+    nit2++;
     // Choose new alpha
     alpha = 0.5*(alphaL + alphaR);
     
@@ -1094,7 +1092,6 @@ int NewFitterGSL::doLineSearch (double& alpha, gsl_vector *vecxnew,
                           << " >= " << phi0 + eta*alpha*dphi0 
                           << " at alpha=" << alpha << endl;
       alphaR = alpha;
-      phiR = phi;
       continue;
     }
     
@@ -1108,8 +1105,6 @@ int NewFitterGSL::doLineSearch (double& alpha, gsl_vector *vecxnew,
                             << " < " << zeta*dphi0 
                             << " at alpha=" << alpha << endl;
         alphaL = alpha;
-        phiL   = phi;
-        dphiL  = dphi;
       }
       else {     
         break;
@@ -1121,13 +1116,12 @@ int NewFitterGSL::doLineSearch (double& alpha, gsl_vector *vecxnew,
                             << " < " << phi0 + zeta*alpha*dphi0 
                             << " at alpha=" << alpha << endl;
         alphaL = alpha;
-        phiL   = phi;
       }
       else {     
         break;
       }  
     }
-  } while (nit < 30 && (alphaL == 0 || nit < 6));
+  } while (nit2 < 30 && (alphaL == 0 || nit2 < 6));
   if (alphaL > 0) alpha = alphaL;
   return 1;
 }
@@ -1339,13 +1333,13 @@ int NewFitterGSL::invertM() {
     return ifail;
 }
 
-void NewFitterGSL::setDebug (int debuglevel) {
-  debug = debuglevel;
+void NewFitterGSL::setDebug (int the_debuglevel) {
+  debug = the_debuglevel;
 }
 
 
 void NewFitterGSL::calcCovMatrix(gsl_matrix *MatW, 
-                                 gsl_permutation *permW,
+                                 gsl_permutation *permW2,
                                  gsl_vector *vecx) {
   // Set up equation system M*dadeta + dydeta = 0
   // here, dadeta is d a / d eta, i.e. the derivatives of the fitted 
@@ -1394,7 +1388,7 @@ void NewFitterGSL::calcCovMatrix(gsl_matrix *MatW,
 
   // Calculate LU decomposition of M into M3
   int signum;
-  int result = gsl_linalg_LU_decomp (MatW, permW, &signum);
+  int result = gsl_linalg_LU_decomp (MatW, permW2, &signum);
  
   if (debug > 3) {
     cout << "calcCovMatrix: gsl_linalg_LU_decomp result=" << result << endl;
@@ -1402,7 +1396,7 @@ void NewFitterGSL::calcCovMatrix(gsl_matrix *MatW,
   }  
 
   // Calculate inverse of M, store in M3
-  int ifail = gsl_linalg_LU_invert (MatW, permW, M3);
+  int ifail = gsl_linalg_LU_invert (MatW, permW2, M3);
   
   if (debug > 3) {
     cout << "calcCovMatrix: gsl_linalg_LU_invert ifail=" << ifail << endl;
@@ -1765,7 +1759,7 @@ int NewFitterGSL::solveSystemLU (      gsl_vector *vecdxscal,
   
 
 int NewFitterGSL::solveSystemSVD (      gsl_vector *vecdxscal, 
-                                         double& detW,
+                                         double& /*detW*/,
                                    const gsl_vector *vecyscal, 
                                    const gsl_matrix *MatMscal,  
                                          gsl_matrix *MatW,   
@@ -1806,7 +1800,7 @@ int NewFitterGSL::solveSystemSVD (      gsl_vector *vecdxscal,
 
 gsl_matrix_view NewFitterGSL::calcZ (int& rankA, gsl_matrix *MatW1,  gsl_matrix *MatW2, 
                                      gsl_vector *vecw1, gsl_vector *vecw2, 
-                                     gsl_permutation *permW, double eps) {
+                                     gsl_permutation *permW2, double eps) {
   assert (MatW1);
   assert (MatW1->size1 == idim && MatW1->size2 == idim);
   assert (MatW2);
@@ -1815,8 +1809,8 @@ gsl_matrix_view NewFitterGSL::calcZ (int& rankA, gsl_matrix *MatW1,  gsl_matrix
   assert (vecw1->size == idim);
   assert (vecw2);
   assert (vecw2->size == idim);
-  assert (permW);
-  assert (permW->size == idim);
+  assert (permW2);
+  assert (permW2->size == idim);
   
   // fill A and AT
   assembleConstDer (MatW2);                    
@@ -1827,9 +1821,9 @@ gsl_matrix_view NewFitterGSL::calcZ (int& rankA, gsl_matrix *MatW1,  gsl_matrix
   gsl_matrix_view R        (gsl_matrix_submatrix       (MatW1, npar, 0,    ncon, npar));
 
   int signum = 0;
-  //gsl_linalg_QRPT_decomp   (&QR.matrix, vecw1, permW, &signum, vecw2);
+  //gsl_linalg_QRPT_decomp   (&QR.matrix, vecw1, permW2, &signum, vecw2);
   //gsl_linalg_QR_unpack     (&QR.matrix, vecw1, &Q.matrix, &R.matrix);
-  gsl_linalg_QRPT_decomp2 (&AT.matrix, &Q.matrix, &R.matrix, vecw1, permW, &signum, vecw2); 
+  gsl_linalg_QRPT_decomp2 (&AT.matrix, &Q.matrix, &R.matrix, vecw1, permW2, &signum, vecw2); 
 
   rankA = 0;
   for (int i = 0; i < ncon; ++i) {
@@ -1843,7 +1837,7 @@ gsl_matrix_view NewFitterGSL::calcReducedHessian (int& rankH, gsl_matrix *MatW1,
                                                   const gsl_vector *vecx, gsl_matrix *MatW2, 
                                                   gsl_matrix *MatW3, 
                                                   gsl_vector *vecw1, gsl_vector *vecw2, 
-                                                  gsl_permutation *permW, double eps) {
+                                                  gsl_permutation *permW2, double eps) {
   assert (MatW1);
   assert (MatW1->size1 == idim && MatW1->size2 == idim);
   assert (vecx);
@@ -1856,12 +1850,12 @@ gsl_matrix_view NewFitterGSL::calcReducedHessian (int& rankH, gsl_matrix *MatW1,
   assert (vecw1->size == idim);
   assert (vecw2);
   assert (vecw2->size == idim);
-  assert (permW);
-  assert (permW->size == idim);
+  assert (permW2);
+  assert (permW2->size == idim);
   
   int rankA;
   // Z is a matrix view of MatW2!
-  gsl_matrix_view Z = calcZ (rankA, MatW2, MatW1, vecw1, vecw2, permW, eps);
+  gsl_matrix_view Z = calcZ (rankA, MatW2, MatW1, vecw1, vecw2, permW2, eps);
   
   // fill Lagrangian
   assembleG (MatW1, vecx);      
@@ -1886,7 +1880,7 @@ gsl_vector_view NewFitterGSL::calcReducedHessianEigenvalues (int& rankH, gsl_mat
                                                   const gsl_vector *vecx, gsl_matrix *MatW2, 
                                                   gsl_matrix *MatW3, 
                                                   gsl_vector *vecw1, gsl_vector *vecw2, 
-                                                  gsl_permutation *permW, gsl_eigen_symm_workspace *eigenws, 
+                                                  gsl_permutation *permW2, gsl_eigen_symm_workspace *eigenws2, 
                                                   double eps) {
   assert (MatW1);
   assert (MatW1->size1 == idim && MatW1->size2 == idim);
@@ -1900,18 +1894,18 @@ gsl_vector_view NewFitterGSL::calcReducedHessianEigenvalues (int& rankH, gsl_mat
   assert (vecw1->size == idim);
   assert (vecw2);
   assert (vecw2->size == idim);
-  assert (permW);
-  assert (permW->size == idim);
-  assert (eigenws);
+  assert (permW2);
+  assert (permW2->size == idim);
+  assert (eigenws2);
   
-  gsl_matrix_view Hred = calcReducedHessian (rankH, MatW1, vecx, MatW2, MatW3, vecw1, vecw2, permW, eps);
+  gsl_matrix_view Hred = calcReducedHessian (rankH, MatW1, vecx, MatW2, MatW3, vecw1, vecw2, permW2, eps);
 
   gsl_matrix_view Hredcopy (gsl_matrix_submatrix       (MatW3, 0,    0,    rankH, rankH));
   // copy Hred -> Hredcopy
   gsl_matrix_memcpy (&Hredcopy.matrix, &Hred.matrix);
     
   gsl_vector_view eval (gsl_vector_subvector (vecw1, 0, rankH));
-  gsl_eigen_symm (&Hredcopy.matrix, &eval.vector, eigenws);
+  gsl_eigen_symm (&Hredcopy.matrix, &eval.vector, eigenws2);
   
   return eval;
 }
diff --git a/src/NewtonFitterGSL.cc b/src/NewtonFitterGSL.cc
index 67cef93..50fc174 100755
--- a/src/NewtonFitterGSL.cc
+++ b/src/NewtonFitterGSL.cc
@@ -95,31 +95,31 @@ NewtonFitterGSL::NewtonFitterGSL()
 // destructor
 NewtonFitterGSL::~NewtonFitterGSL() {
 
-  if (x) gsl_vector_free (x);               x=0;
-  if (xold) gsl_vector_free (xold);         xold=0;
-  if (xbest) gsl_vector_free (xbest);       xbest=0;
-  if (dx) gsl_vector_free (dx);             dx=0;
-  if (dxscal) gsl_vector_free (dxscal);     dxscal=0;
-  if (grad) gsl_vector_free (grad);         grad=0;
-  if (y) gsl_vector_free (y);               y=0;
-  if (yscal) gsl_vector_free (yscal);       yscal=0;
-  if (perr) gsl_vector_free (perr);         perr=0;
-  if (v1) gsl_vector_free (v1);             v1=0;
-  if (v2) gsl_vector_free (v2);             v2=0;
-  if (Meval) gsl_vector_free (Meval);       Meval=0;
-  if (M) gsl_matrix_free (M);               M=0;
-  if (Mscal) gsl_matrix_free (Mscal);       Mscal=0;
-  if (M1) gsl_matrix_free (M1);             M1=0;
-  if (M2) gsl_matrix_free (M2);             M2=0;
-  if (M3) gsl_matrix_free (M3);             M3=0;
-  if (M4) gsl_matrix_free (M4);             M4=0;
-  if (M5) gsl_matrix_free (M5);             M5=0;
-  if (Mevec) gsl_matrix_free (Mevec);       Mevec=0;
-  if (CC) gsl_matrix_free (CC);             CC=0;
-  if (CC1) gsl_matrix_free (CC1);           CC1=0;
-  if (CCinv) gsl_matrix_free (CCinv);       CCinv=0;
-  if (permM) gsl_permutation_free (permM);  permM=0;
-  if (ws) gsl_eigen_symmv_free (ws);        ws=0; wsdim=0;
+  if (x) gsl_vector_free (x);
+  if (xold) gsl_vector_free (xold);
+  if (xbest) gsl_vector_free (xbest);
+  if (dx) gsl_vector_free (dx);
+  if (dxscal) gsl_vector_free (dxscal);
+  if (grad) gsl_vector_free (grad);
+  if (y) gsl_vector_free (y);
+  if (yscal) gsl_vector_free (yscal);
+  if (perr) gsl_vector_free (perr);
+  if (v1) gsl_vector_free (v1);
+  if (v2) gsl_vector_free (v2);
+  if (Meval) gsl_vector_free (Meval);
+  if (M) gsl_matrix_free (M);
+  if (Mscal) gsl_matrix_free (Mscal);
+  if (M1) gsl_matrix_free (M1);
+  if (M2) gsl_matrix_free (M2);
+  if (M3) gsl_matrix_free (M3);
+  if (M4) gsl_matrix_free (M4);
+  if (M5) gsl_matrix_free (M5);
+  if (Mevec) gsl_matrix_free (Mevec);
+  if (CC) gsl_matrix_free (CC);
+  if (CC1) gsl_matrix_free (CC1);
+  if (CCinv) gsl_matrix_free (CCinv);
+  if (permM) gsl_permutation_free (permM);
+  if (ws) gsl_eigen_symmv_free (ws);
 }
 
 
@@ -164,7 +164,7 @@ double NewtonFitterGSL::fit() {
   bool converged = 0;
   ierr = 0;
   
-  double chi2new = calcChi2();
+  double chi2new2 = calcChi2();
   nit = 0;
   if (debug>1) {
     cout << "Fit objects:\n";
@@ -208,7 +208,7 @@ double NewtonFitterGSL::fit() {
   
   do {
   
-    double chi2old = chi2new;
+    double chi2old2 = chi2new2;
     
     if (debug>1 && (nit==0 || nit<nitdebug)) cout << "===================\nStarting iteration " << nit << endl;
     if (debug>2 && (nit==0 || nit<nitdebug)) {
@@ -279,8 +279,8 @@ double NewtonFitterGSL::fit() {
 
     calcy();
     //cout << "New fval: " << 0.5*pow(gsl_blas_dnrm2 (yscal), 2) << endl;
-    chi2new = calcChi2();
-    //cout << "chi2: " << chi2old << " -> " << chi2new << endl;
+    chi2new2 = calcChi2();
+    //cout << "chi2: " << chi2old2 << " -> " << chi2new2 << endl;
    
     if (debug>3 && (nit==0 || nit<nitdebug)) {
       cout << "After solving equations: \n";
@@ -291,16 +291,16 @@ double NewtonFitterGSL::fit() {
 //   *-- Convergence criteria 
 
     if (debug > 1&& nit<nitdebug) {
-      cout << "old chi2: " << chi2old << ", new chi2: " << chi2new << ", diff=" << chi2old-chi2new << endl;
+      cout << "old chi2: " << chi2old2 << ", new chi2: " << chi2new2 << ", diff=" << chi2old2-chi2new2 << endl;
     }
     ++nit;
     if (nit > 200) ierr = 1;
     
-    converged = (abs (chi2new - chi2old) < 0.001 && fvalbest < 1E-3 && 
+    converged = (abs (chi2new2 - chi2old2) < 0.001 && fvalbest < 1E-3 && 
                 (fvalbest < 1E-6 || abs(fvals[0]-fvalbest) < 0.2*fvalbest));
                 
-//     if (abs (chi2new - chi2old) >= 0.001)
-//       cout << "abs (chi2new - chi2old)=" << abs (chi2new - chi2old) << " -> try again\n";      
+//     if (abs (chi2new2 - chi2old2) >= 0.001)
+//       cout << "abs (chi2new2 - chi2old2)=" << abs (chi2new2 - chi2old2) << " -> try again\n";      
 //     if (fvalbest >= 1E-3)
 //       cout << "fvalbest=" << fvalbest << " -> try again\n";      
 //     if (fvalbest >= 1E-6 && abs(fvals[0]-fvalbest) >= 0.2*fvalbest )
@@ -310,7 +310,7 @@ double NewtonFitterGSL::fit() {
 //       cout << "stepbest=" << stepbest << " -> try again\n";      
 //     cout << "converged=" << converged << endl;
     if (debug > 0 && converged) {
-      cout << "abs (chi2new - chi2old)=" << abs (chi2new - chi2old) << "\n"      
+      cout << "abs (chi2new2 - chi2old2)=" << abs (chi2new2 - chi2old2) << "\n"      
            << "fvalbest=" << fvalbest << "\n"
            << "abs(fvals[0]-fvalbest)=" << abs(fvals[0]-fvalbest)<< "\n";      
     } 
@@ -361,7 +361,7 @@ double NewtonFitterGSL::fit() {
   }
 
 // *-- Turn chisq into probability.
-  fitprob = (chi2new >= 0 && ncon+nsoft-nunm> 0) ? gsl_cdf_chisq_Q(chi2new, ncon+nsoft-nunm) : -1;
+  fitprob = (chi2new2 >= 0 && ncon+nsoft-nunm> 0) ? gsl_cdf_chisq_Q(chi2new2, ncon+nsoft-nunm) : -1;
   
 #ifndef FIT_TRACEOFF
     if (tracer) tracer->finish (*this);
@@ -402,7 +402,7 @@ bool NewtonFitterGSL::initialize() {
   // set number of constraints
   ncon = constraints.size();
   // Tell the constraints their numbers
-  for (unsigned int icon = 0; icon < ncon; ++icon) {
+  for (int icon = 0; icon < ncon; ++icon) {
     BaseHardConstraint *c = constraints[icon];
     assert (c);
     if (debug > 3) cout << "NewtonFitterGSL::initialize: constraint " << c->getName() 
@@ -473,11 +473,11 @@ double NewtonFitterGSL::calcChi2() {
   return chi2;
 }
 
-void NewtonFitterGSL::printMy (double M[], double y[], int idim) {
-  for (int i = 0; i < idim; ++i) {
-    cout << i << "  [ " << M[idim*i+0];
-      for (int j = 1; j<idim; ++j) cout << ", " << M[idim*i+j];
-      cout << "]  [" << y[i] << "]\n";
+void NewtonFitterGSL::printMy (double the_M[], double the_y[], int the_idim) {
+  for (int i = 0; i < the_idim; ++i) {
+    cout << i << "  [ " << the_M[the_idim*i+0];
+      for (int j = 1; j<the_idim; ++j) cout << ", " << the_M[the_idim*i+j];
+      cout << "]  [" << the_y[i] << "]\n";
   }
 }
 
@@ -545,18 +545,18 @@ int NewtonFitterGSL::calcDxSVD () {
 //     cout << "Complete system:\n";
 //     printMy(M, y, idim);
      // Get eigenvalues and eigenvectors of Mscal
-     int ierr=0;
+     int ierr2=0;
      gsl_matrix_memcpy (M1, Mscal);
      if (debug > 3) cout << "NewtonFitterGSL::calcDxSVD: Calling gsl_eigen_symmv" << endl;
-     ierr = gsl_eigen_symmv (M1, Meval, Mevec, ws); 
-     if (debug > 3) cout << "NewtonFitterGSL::calcDxSVD: result of gsl_eigen_symmv: " << ierr << endl;
-     if (ierr != 0) {
-       cerr << "NewtonFitter::calcDxSVD: ierr=" << ierr << "from gsl_eigen_symmv!\n";
+     ierr2 = gsl_eigen_symmv (M1, Meval, Mevec, ws); 
+     if (debug > 3) cout << "NewtonFitterGSL::calcDxSVD: result of gsl_eigen_symmv: " << ierr2 << endl;
+     if (ierr2 != 0) {
+       cerr << "NewtonFitter::calcDxSVD: ierr=" << ierr2 << "from gsl_eigen_symmv!\n";
      }
      // Sort the eigenvalues and eigenvectors in descending order in magnitude
-     ierr = gsl_eigen_symmv_sort (Meval, Mevec, GSL_EIGEN_SORT_ABS_DESC);
-     if (ierr != 0) {
-       cerr << "NewtonFitter::calcDxSVD: ierr=" << ierr << "from gsl_eigen_symmv_sort!\n";
+     ierr2 = gsl_eigen_symmv_sort (Meval, Mevec, GSL_EIGEN_SORT_ABS_DESC);
+     if (ierr2 != 0) {
+       cerr << "NewtonFitter::calcDxSVD: ierr=" << ierr2 << "from gsl_eigen_symmv_sort!\n";
      }
      
      
@@ -898,7 +898,7 @@ int NewtonFitterGSL::optimizeScale () {
   // Code adapted from Numerical Recipies (3rd ed), page 479
   // routine lnsrch
   
-  int nit = 0;
+  int nit2 = 0;
   
   static const double ALF = 1E-4;
   
@@ -945,37 +945,37 @@ int NewtonFitterGSL::optimizeScale () {
       debug_print (x, "x(3)");  
       debug_print (yscal, "yscal");  
     }
-    ++nit;
-    scalevals[nit] = scale;
-    fvals[nit] = 0.5*pow (gsl_blas_dnrm2 (yscal), 2);
+    ++nit2;
+    scalevals[nit2] = scale;
+    fvals[nit2] = 0.5*pow (gsl_blas_dnrm2 (yscal), 2);
     
     chi2new = calcChi2();
     
     
-//    if (chi2new <= chi2best && fvals[nit] <= fvalbest) {
-//    if ((fvals[nit] < fvalbest && chi2new <= chi2best) ||
-//        (fvals[nit] < 1E-4 && chi2new < chi2best)) {
-    if ((fvals[nit] < fvalbest)) {
+//    if (chi2new <= chi2best && fvals[nit2] <= fvalbest) {
+//    if ((fvals[nit2] < fvalbest && chi2new <= chi2best) ||
+//        (fvals[nit2] < 1E-4 && chi2new < chi2best)) {
+    if ((fvals[nit2] < fvalbest)) {
       if (debug > 3) {
         cout << "new best value: "
-             << "  scale " << scalevals[nit] << " -> |y|^2 = " << fvals[nit] 
+             << "  scale " << scalevals[nit2] << " -> |y|^2 = " << fvals[nit2] 
              << ", chi2=" << chi2new << ", old best chi2: " << chi2best << endl;      
       }
       gsl_vector_memcpy (xbest, x);
       chi2best = chi2new;
-      fvalbest = fvals[nit];
+      fvalbest = fvals[nit2];
       scalebest = scale;
       stepbest = scale*stepsize;
     }
     
-    if (fvals[nit] < fvals[0] + ALF*scale*slope) break;
-    if (nit == 1) {
-      tmpscale = -slope/(2*(fvals[nit] - fvals[0] - slope));
+    if (fvals[nit2] < fvals[0] + ALF*scale*slope) break;
+    if (nit2 == 1) {
+      tmpscale = -slope/(2*(fvals[nit2] - fvals[0] - slope));
       if (debug > 3) cout << "quadratic estimate for best scale: " << tmpscale << endl;
     }
     else {
-      double rhs1 = fvals[nit] - fvals[0]-scale*slope;
-      double rhs2 = fvals[nit-1] - fvals[0]-scaleold*slope;
+      double rhs1 = fvals[nit2] - fvals[0]-scale*slope;
+      double rhs2 = fvals[nit2-1] - fvals[0]-scaleold*slope;
       double a = (rhs1/(scale*scale)-rhs2/(scaleold*scaleold))/(scale-scaleold);
       double b = (-scaleold*rhs1/(scale*scale)+scale*rhs2/(scaleold*scaleold))/(scale-scaleold);
       if (a==0) tmpscale = -slope/(2*b);
@@ -992,10 +992,10 @@ int NewtonFitterGSL::optimizeScale () {
     scale = (tmpscale < 0.1*scale) ? 0.1*scale : tmpscale;
     if (debug > 1) cout << "New scale: " << scale << endl;
     
-  } while (nit < NITMAX && scale > 0.0001);
+  } while (nit2 < NITMAX && scale > 0.0001);
 
   if (debug > 1) {
-    for (int it = 0; it <= nit; ++it) {
+    for (int it = 0; it <= nit2; ++it) {
       cout << "  scale " << scalevals[it] << " -> |y|^2 = " << fvals[it] 
       << " should be " << fvals[0] + ALF*scale*slope << endl;
     }
@@ -1154,7 +1154,7 @@ double NewtonFitterGSL::meritFunction(double mu) {
   return result;
 }
 
-double NewtonFitterGSL::meritFunctionDeriv(double mu) {
+double NewtonFitterGSL::meritFunctionDeriv(double /*mu*/) {
   double result = 0;
   switch (imerit) {
     case 1: 
diff --git a/src/ParticleFitObject.cc b/src/ParticleFitObject.cc
index eafb5d3..2ac5b92 100644
--- a/src/ParticleFitObject.cc
+++ b/src/ParticleFitObject.cc
@@ -74,7 +74,7 @@ ParticleFitObject::~ParticleFitObject()
 {}
 
 ParticleFitObject::ParticleFitObject (const ParticleFitObject& rhs)
-  : mass(0), fourMomentum( FourVector(0,0,0,0) )
+  : BaseFitObject(rhs), mass(0), fourMomentum( FourVector(0,0,0,0) )
 {
   //std::cout << "copying ParticleFitObject with name" << rhs.name << std::endl;
   ParticleFitObject::assign (rhs);
@@ -163,7 +163,7 @@ std::ostream&  ParticleFitObject::print (std::ostream& os) const {
   return os;
 }
 
-void ParticleFitObject::addToGlobalChi2DerVectorNum (double *y, int idim, double eps)  {
+void ParticleFitObject::addToGlobalChi2DerVectorNum (double *y, int /*idim*/, double eps)  {
   for (int ilocal = 0; ilocal < getNPar(); ++ilocal) {
     int iglobal = getGlobalParNum(ilocal);
     y[iglobal] += num1stDerivative (ilocal, eps);
diff --git a/src/SimplePhotonFitObject.cc b/src/SimplePhotonFitObject.cc
index b2b932c..b2585e8 100644
--- a/src/SimplePhotonFitObject.cc
+++ b/src/SimplePhotonFitObject.cc
@@ -61,7 +61,8 @@ SimplePhotonFitObject::SimplePhotonFitObject(double px, double py, double pz, do
 // destructor
 SimplePhotonFitObject::~SimplePhotonFitObject() {}
 
-SimplePhotonFitObject::SimplePhotonFitObject (const SimplePhotonFitObject& rhs) : pt2(0), p2(0), p(0),dE0(0), dE1(0), dE2(0),chi2(0)
+SimplePhotonFitObject::SimplePhotonFitObject (const SimplePhotonFitObject& rhs) : ParticleFitObject(rhs),
+                                                                                  pt2(0), p2(0), p(0),dE0(0), dE1(0), dE2(0),chi2(0)
 {
   //std::cout << "copying SimplePhotonFitObject with name" << rhs.name << std::endl;
   SimplePhotonFitObject::assign (rhs);
diff --git a/src/SoftGaussMomentumConstraint.cc b/src/SoftGaussMomentumConstraint.cc
index 3f372b2..7ab860c 100644
--- a/src/SoftGaussMomentumConstraint.cc
+++ b/src/SoftGaussMomentumConstraint.cc
@@ -78,15 +78,15 @@ void SoftGaussMomentumConstraint::getDerivatives(int idim, double der[]) const {
 }
   
 
-bool SoftGaussMomentumConstraint::firstDerivatives (int i, double *derivatives) const {
-  derivatives[0] = efact;
-  derivatives[1] = pxfact;
-  derivatives[2] = pyfact;
-  derivatives[3] = pzfact;
+bool SoftGaussMomentumConstraint::firstDerivatives (int /*i*/, double *deriv) const {
+  deriv[0] = efact;
+  deriv[1] = pxfact;
+  deriv[2] = pyfact;
+  deriv[3] = pzfact;
   return true;
 }
 
-bool SoftGaussMomentumConstraint::secondDerivatives (int i, int j, double *derivatives) const {
+bool SoftGaussMomentumConstraint::secondDerivatives (int /*i*/, int /*j*/, double */*derivatives*/) const {
   return false;
 }  
   
diff --git a/src/TopEventILC.cc b/src/TopEventILC.cc
index b65ff24..4b25f95 100644
--- a/src/TopEventILC.cc
+++ b/src/TopEventILC.cc
@@ -45,12 +45,12 @@ TopEventILC::TopEventILC()
   pyc (0, 0, 1),
   pzc (0, 0, 0, 1),
   ec  (1, 0, 0, 0, 500), 
-  sw1 (2.1/(2.*sqrt(0.805)), 80.4),  // Thesis Jenny p44
-  sw2 (2.1/(2.*sqrt(0.805)), 80.4),
-  sw (1.4/sqrt(0.805)),
   w1 (80.4),  
   w2 (80.4),
-  w (0)
+  w (0),
+  sw1 (2.1/(2.*sqrt(0.805)), 80.4),  // Thesis Jenny p44
+  sw2 (2.1/(2.*sqrt(0.805)), 80.4),
+  sw (1.4/sqrt(0.805))
   {
   for (int i = 0; i < NFV; ++i) fv[i] = 0;
   for (int i = 0; i < NBFO; ++i) bfo[i] = bfosmear[i] = 0;
@@ -290,19 +290,19 @@ void TopEventILC::genEvent(){
 //      double en =  sqrt (pxn*pxn+pyn*pyn+pzn*pzn);
       double en =  Ecm - Etot;
       double ptn = sqrt(pxn*pxn+pyn*pyn);
-      double theta = acos (pzn/pn); 
-      double phi = atan2 (pyn, pxn);
+      double theta_ = acos (pzn/pn); 
+      double phi_ = atan2 (pyn, pxn);
 //       if (en <= 0) {
 //         cout << "WARNING: negative missing energy = " << en << ", setting to pn = " << pn << ", true pn = " << bfo[5]->getE() << endl;
 //         en = pn;
 //       }   
       if (debug) {
-        cout << "Neutrino: en = " << en << ", theta = " << theta << ", phi = " << phi << endl;
+        cout << "Neutrino: en = " << en << ", theta = " << theta_ << ", phi = " << phi_ << endl;
         cout << "Neutrino: pxn = " << pxn << ", pyn = " << pyn << ", pzn = " << pzn << ", pn = " << pn << endl;
-        cout << "Neutrino momenta by hand: px = " << ptn*cos(phi) << ", py = " << ptn*sin(phi) << ", pz = " << pn*cos(theta) << endl;
+        cout << "Neutrino momenta by hand: px = " << ptn*cos(phi_) << ", py = " << ptn*sin(phi_) << ", pz = " << pn*cos(theta_) << endl;
       }   
-      bfosmear[5] = new NeutrinoFitObject (pn, theta, phi, 14, 0.32, 0.425);  // adjust such that "pull vs true" has width ~1
-      bfostart[5] = new NeutrinoFitObject (pn, theta, phi, 14, 0.32, 0.425);  // adjust such that "pull vs true" has width ~1
+      bfosmear[5] = new NeutrinoFitObject (pn, theta_, phi_, 14, 0.32, 0.425);  // adjust such that "pull vs true" has width ~1
+      bfostart[5] = new NeutrinoFitObject (pn, theta_, phi_, 14, 0.32, 0.425);  // adjust such that "pull vs true" has width ~1
     
       bfosmear[5]->setName ("n22");
       bfostart[5]->setName ("n22");
diff --git a/src/TrackParticleFitObject.cc b/src/TrackParticleFitObject.cc
index 606f317..9a7c134 100644
--- a/src/TrackParticleFitObject.cc
+++ b/src/TrackParticleFitObject.cc
@@ -173,7 +173,8 @@ TrackParticleFitObject::~TrackParticleFitObject() {}
 
 
 TrackParticleFitObject::TrackParticleFitObject (const TrackParticleFitObject& rhs)
-  : trackReferencePoint( ThreeVector(0,0,0) ),
+  : ParticleFitObject(rhs),
+    trackReferencePoint( ThreeVector(0,0,0) ),
     trackPlaneNormal( ThreeVector(0,0,0) ),
     trackPcaVector( ThreeVector(0,0,0) ),
     trajectoryPointAtPCA( ThreeVector(0,0,0) ),
@@ -227,7 +228,7 @@ const char *TrackParticleFitObject::getParamName (int ilocal) const {
   return "undefined";
 }
 
-bool TrackParticleFitObject::updateParams (double p[], int idim) {
+bool TrackParticleFitObject::updateParams (double p[], int /*idim*/) {
   invalidateCache();
 
   double tempPar[NPAR]={0};
@@ -476,7 +477,6 @@ void TrackParticleFitObject::updateTrajectoryDerivatives() const {
   double D = d0;
   double P = phi0;
   double W = omega;
-  double Z = z0;
   double T = tanl;
   double S(0);
   
diff --git a/src/VertexFitObject.cc b/src/VertexFitObject.cc
index 44c29b1..58df4e8 100644
--- a/src/VertexFitObject.cc
+++ b/src/VertexFitObject.cc
@@ -57,7 +57,8 @@ VertexFitObject::VertexFitObject(const char *name_,
 
 }
 
-VertexFitObject::VertexFitObject (const VertexFitObject& rhs) 
+VertexFitObject::VertexFitObject (const VertexFitObject& rhs)
+  : BaseFitObject(rhs)
 {
   //  copy (rhs);
   VertexFitObject::assign (rhs);
diff --git a/src/ZinvisibleFitObject.cc b/src/ZinvisibleFitObject.cc
index 78eb767..9ac40e5 100644
--- a/src/ZinvisibleFitObject.cc
+++ b/src/ZinvisibleFitObject.cc
@@ -43,7 +43,8 @@ ZinvisibleFitObject::ZinvisibleFitObject(double E, double theta, double phi,
 ZinvisibleFitObject::~ZinvisibleFitObject() {}
 
 ZinvisibleFitObject::ZinvisibleFitObject (const ZinvisibleFitObject& rhs)
-  : cachevalid(false), ctheta(0), stheta(0), cphi(0), sphi(0),p2(0), p(0), dpdE(0), pt(0), px(0), py(0), pz(0), dptdE(0),
+  : ParticleFitObject(rhs),
+    cachevalid(false), ctheta(0), stheta(0), cphi(0), sphi(0),p2(0), p(0), dpdE(0), pt(0), px(0), py(0), pz(0), dptdE(0),
     dpxdE(0), dpydE(0), dpxdtheta(0), dpydtheta(0), chi2(0)
 {
   //std::cout << "copying ZinvisibleFitObject with name" << rhs.name << std::endl;
